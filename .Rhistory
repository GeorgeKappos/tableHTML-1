invisible(htmltable)
}
a <- tableHTML(mtcars)
#' Create an easily css-ible HTML table
#'
#' The purpose of \code{tableHTML} is to create easily css-ible HTML tables
#' that are compatible with R shiny. The exported HTML table will contain separate ids
#' or classes for headers, columns, second headers (if any) and the table itself
#' (in case you have multiple tables) in order to create a
#' complex css file very easily. ids and classes are explained in detail in
#' the details section.
#'
#' \code{tableHTML} will create an HTML table with defined ids and classes for rows and columns.
#' In particular:
#' \itemize{
#'   \item \strong{Table:} Will get the class from the class argument in the function.
#'       The final class will be of the form table_<class_name>.
#'   \item \strong{Columns:} Will get an id which will be the same as the column name
#'   \item \strong{Headers:} Will get an id of the form header_<header index>.
#'       For example the first header will have the id header_1, the second header
#'       will have header_2 and so on.
#'   \item \strong{Second_Header:} Will get an id of the form overheader_<second header index>.
#'       For example the first second_header will have the id overheader_1, the second header
#'       will have overheader_2 and so on.
#' }
#'
#' Notice that rows do not get a specific id or class as they are easily accessible from css
#' anyway.
#'
#' @param obj Needs to be a data.frame or a matrix or an arbitrary object that has the
#'   data.frame class and can be coersible to a data.frame (e.g data.table, tbl, etc.)
#'
#' @param rownames Can be TRUE or FALSE. Defaults to TRUE. Whether the obj's rownames
#'   will be inlcuded.
#'
#' @param class Character String. Specifies the table's class. Convinient if you have multiple
#'   tables. Default is table_<data_frame_name>.
#'
#' @param widths Needs to be a numeric atomic vector with the column widths. Widths are in pixels.
#'
#' @param second_header A list of two elements of the same length. The first element will contain
#'   the column spans (i.e. a numeric atomic vector) whereas the second element will contain the
#'   names (i.e. a character atomic vector). See the examples for more info. Defauls to NULL.
#'
#' @return An tableHTML object. Printing the table will result in rendering it in R studio's viewer
#'         with the print.tableHTML method. Use \code{str(tableHTML)} to view the actual html code.
#'
#' @examples
#' tableHTML(mtcars)
#' tableHtML(mtcars, rownames = FALSE)
#' tableHTML(mtcars, class = 'table1')
#' tableHTML(mtcars, second_header = list(c(3, 4, 5), c('col1', 'col2', 'col3')))
#' tableHTML(mtcars,
#'           widths = c(rep(50, 6), rep(100, 6)) ,
#'           second_header = list(c(3,4,5), c('col1', 'col2', 'col3')))
#'
#' @export
tableHTML <- function(obj,
rownames = TRUE,
class = paste0('table_', deparse(substitute(obj))),
widths = NULL,
second_header = NULL) {
#CHECKS----------------------------------------------------------------------------------------
#adding checks for obj
if (is.matrix(obj)) {
obj <- as.data.frame(obj)
} else if (!inherits(obj, 'data.frame')) {
stop('obj needs to be either a data.frame or a matrix')
}
#checks for second header
if (!is.null(second_header)) {
if (!is.list(second_header)) {
stop('second_header needs to be a list')
}
if (length(second_header) != 2L) {
stop('second_header needs to be a list of length two')
}
if (!is.numeric(second_header[[1]])) {
stop("second_header\'s first element needs to be numeric")
}
if (!is.character(second_header[[2]])) {
stop("second_header\'s second element needs to be character")
}
if (length(second_header[[1]]) != length(second_header[[2]])) {
stop("second_header\'s  elements need to have the same length")
}
}
if(rownames == TRUE & !is.null(widths)) {
if (length(widths) != ncol(obj) + 1) stop('widths need to have the same length as the columns')
} else if(rownames == FALSE & !is.null(widths)) {
if (length(widths) != ncol(obj)) stop('widths need to have the same length as the columns')
}
#HEADERS---------------------------------------------------------------------------------------
#taking into account rownames
if (rownames == TRUE) {
headers <- paste('\n<tr>',
'  <th id=header_1> </th>',
paste(vapply(seq_along(names(obj)) + 1, function(x) {
paste0('  <th id=header_', x, '>',
names(obj)[x - 1],
'</th>')
},
FUN.VALUE = character(1)),
collapse = '\n'),
'</tr>',
sep = '\n')
} else {
headers <- paste('\n<tr>',
paste(vapply(seq_along(names(obj)), function(x) {
paste0('  <th id=header_', x, '>', names(obj)[x], '</th>')
},
FUN.VALUE = character(1)),
collapse = '\n'),
'</tr>',
sep = '\n')
}
#SECOND HEADERS--------------------------------------------------------------------------------
#adding second headers if needed
if (!is.null(second_header)) {
over_header <-
paste('<tr>',
paste(vapply(seq_along(second_header[[1]]), function(x) {
paste0('  <th colspan=',
second_header[[1]][x],
' id=overheader_',
x,
'>',
second_header[[2]][x],
'</th>')
},
FUN.VALUE = character(1)),
collapse = '\n'),
'</tr>',
sep = '\n')
} else {
over_header <- NULL
}
#TABLE'S BODY----------------------------------------------------------------------------------
#adding body
content <- lapply(names(obj), function(x) {
paste0('  <td id="', x, '">', obj[[x]], '</td>\n')
})
#adding rownames in the body
if (rownames == TRUE) {
content <- c(list(paste0('  <td id="rownames">',
row.names(obj),
'</td>\n')),
content)
}
content <- cbind('<tr>\n', do.call(cbind, content), '</tr>')
content <- paste(apply(content, 1, paste, collapse = ''), collapse = '\n')
#WIDTHS----------------------------------------------------------------------------------------
#setting column widths if any------------------------------------------------------------------
if (!is.null(widths)) {
colwidths <- paste(
vapply(widths, function(x) {
paste0('<col width="', x, '">')
}, FUN.VALUE = character(1)),
collapse = '\n')
}
#PUTTING IT ALL TOGETHER-----------------------------------------------------------------------
#adding all the components in one html table
htmltable <-
htmltools::HTML(paste0('\n<table class=',
class,
' border=1 style="border-collapse: collapse;">\n',
over_header,
'\n',
colwidths,
headers,
content,
'\n',
'</table>',
collapse=''))
class(htmltable) <- c('tableHTML', class(htmltable))
htmltable
}
#' @rdname tableHTML
#' @export
print.tableHTML <- function(htmltable) {
if (interactive()) {
viewer <- getOption("viewer")
file <- tempfile(fileext = ".html")
htmlfile <- htmltools::HTML(paste('<html>\n<body>',
htmltable,
'</body>\n</html>',
sep = '\n'))
cat(htmlfile, file = file)
viewer(file)
}
invisible(htmltable)
}
a <- tableHTML(mtcars)
#' Create an easily css-ible HTML table
#'
#' The purpose of \code{tableHTML} is to create easily css-ible HTML tables
#' that are compatible with R shiny. The exported HTML table will contain separate ids
#' or classes for headers, columns, second headers (if any) and the table itself
#' (in case you have multiple tables) in order to create a
#' complex css file very easily. ids and classes are explained in detail in
#' the details section.
#'
#' \code{tableHTML} will create an HTML table with defined ids and classes for rows and columns.
#' In particular:
#' \itemize{
#'   \item \strong{Table:} Will get the class from the class argument in the function.
#'       The final class will be of the form table_<class_name>.
#'   \item \strong{Columns:} Will get an id which will be the same as the column name
#'   \item \strong{Headers:} Will get an id of the form header_<header index>.
#'       For example the first header will have the id header_1, the second header
#'       will have header_2 and so on.
#'   \item \strong{Second_Header:} Will get an id of the form overheader_<second header index>.
#'       For example the first second_header will have the id overheader_1, the second header
#'       will have overheader_2 and so on.
#' }
#'
#' Notice that rows do not get a specific id or class as they are easily accessible from css
#' anyway.
#'
#' @param obj Needs to be a data.frame or a matrix or an arbitrary object that has the
#'   data.frame class and can be coersible to a data.frame (e.g data.table, tbl, etc.)
#'
#' @param rownames Can be TRUE or FALSE. Defaults to TRUE. Whether the obj's rownames
#'   will be inlcuded.
#'
#' @param class Character String. Specifies the table's class. Convinient if you have multiple
#'   tables. Default is table_<data_frame_name>.
#'
#' @param widths Needs to be a numeric atomic vector with the column widths. Widths are in pixels.
#'
#' @param second_header A list of two elements of the same length. The first element will contain
#'   the column spans (i.e. a numeric atomic vector) whereas the second element will contain the
#'   names (i.e. a character atomic vector). See the examples for more info. Defauls to NULL.
#'
#' @return An tableHTML object. Printing the table will result in rendering it in R studio's viewer
#'         with the print.tableHTML method. Use \code{str(tableHTML)} to view the actual html code.
#'
#' @examples
#' tableHTML(mtcars)
#' tableHtML(mtcars, rownames = FALSE)
#' tableHTML(mtcars, class = 'table1')
#' tableHTML(mtcars, second_header = list(c(3, 4, 5), c('col1', 'col2', 'col3')))
#' tableHTML(mtcars,
#'           widths = c(rep(50, 6), rep(100, 6)) ,
#'           second_header = list(c(3,4,5), c('col1', 'col2', 'col3')))
#'
#' @export
tableHTML <- function(obj,
rownames = TRUE,
class = paste0('table_', deparse(substitute(obj))),
widths = NULL,
second_header = NULL) {
#CHECKS----------------------------------------------------------------------------------------
#adding checks for obj
if (is.matrix(obj)) {
obj <- as.data.frame(obj)
} else if (!inherits(obj, 'data.frame')) {
stop('obj needs to be either a data.frame or a matrix')
}
#checks for second header
if (!is.null(second_header)) {
if (!is.list(second_header)) {
stop('second_header needs to be a list')
}
if (length(second_header) != 2L) {
stop('second_header needs to be a list of length two')
}
if (!is.numeric(second_header[[1]])) {
stop("second_header\'s first element needs to be numeric")
}
if (!is.character(second_header[[2]])) {
stop("second_header\'s second element needs to be character")
}
if (length(second_header[[1]]) != length(second_header[[2]])) {
stop("second_header\'s  elements need to have the same length")
}
}
if(rownames == TRUE & !is.null(widths)) {
if (length(widths) != ncol(obj) + 1) stop('widths need to have the same length as the columns')
} else if(rownames == FALSE & !is.null(widths)) {
if (length(widths) != ncol(obj)) stop('widths need to have the same length as the columns')
}
#HEADERS---------------------------------------------------------------------------------------
#taking into account rownames
if (rownames == TRUE) {
headers <- paste('\n<tr>',
'  <th id=header_1> </th>',
paste(vapply(seq_along(names(obj)) + 1, function(x) {
paste0('  <th id=header_', x, '>',
names(obj)[x - 1],
'</th>')
},
FUN.VALUE = character(1)),
collapse = '\n'),
'</tr>',
sep = '\n')
} else {
headers <- paste('\n<tr>',
paste(vapply(seq_along(names(obj)), function(x) {
paste0('  <th id=header_', x, '>', names(obj)[x], '</th>')
},
FUN.VALUE = character(1)),
collapse = '\n'),
'</tr>',
sep = '\n')
}
#SECOND HEADERS--------------------------------------------------------------------------------
#adding second headers if needed
if (!is.null(second_header)) {
over_header <-
paste('<tr>',
paste(vapply(seq_along(second_header[[1]]), function(x) {
paste0('  <th colspan=',
second_header[[1]][x],
' id=overheader_',
x,
'>',
second_header[[2]][x],
'</th>')
},
FUN.VALUE = character(1)),
collapse = '\n'),
'</tr>',
sep = '\n')
} else {
over_header <- NULL
}
#TABLE'S BODY----------------------------------------------------------------------------------
#adding body
content <- lapply(names(obj), function(x) {
paste0('  <td id="', x, '">', obj[[x]], '</td>\n')
})
#adding rownames in the body
if (rownames == TRUE) {
content <- c(list(paste0('  <td id="rownames">',
row.names(obj),
'</td>\n')),
content)
}
content <- cbind('<tr>\n', do.call(cbind, content), '</tr>')
content <- paste(apply(content, 1, paste, collapse = ''), collapse = '\n')
#WIDTHS----------------------------------------------------------------------------------------
#setting column widths if any------------------------------------------------------------------
if (!is.null(widths)) {
colwidths <- paste(
vapply(widths, function(x) {
paste0('<col width="', x, '">')
}, FUN.VALUE = character(1)),
collapse = '\n')
} else {
colwidths <- NULL
}
#PUTTING IT ALL TOGETHER-----------------------------------------------------------------------
#adding all the components in one html table
htmltable <-
htmltools::HTML(paste0('\n<table class=',
class,
' border=1 style="border-collapse: collapse;">\n',
over_header,
'\n',
colwidths,
headers,
content,
'\n',
'</table>',
collapse=''))
class(htmltable) <- c('tableHTML', class(htmltable))
htmltable
}
#' @rdname tableHTML
#' @export
print.tableHTML <- function(htmltable) {
if (interactive()) {
viewer <- getOption("viewer")
file <- tempfile(fileext = ".html")
htmlfile <- htmltools::HTML(paste('<html>\n<body>',
htmltable,
'</body>\n</html>',
sep = '\n'))
cat(htmlfile, file = file)
viewer(file)
}
invisible(htmltable)
}
a <- tableHTML(mtcars)
str(a)
tableHTML(mtcars, rownames = FALSE)
library(devtools)
setwd('c:/github/tableHTML/')
load_all()
css = list(c('background-color', 'border'), c('lightgray', '3px solid green'))
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 1)
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
i
paste0('id="header_', i, '" style=')
paste0('id=header"', i, '"')
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
paste0('id="header_', i, '" style=')
paste0('id=header_"', i, '"')
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
load_all()
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
paste0('id="header_', i, '" style=')
paste0('id="header_', i, '"')
paste0('id="header_', i, '"')
paste0('id="header_', i, '" ', style)
load_all()
a <- tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
str(a)
load_all()
a <- tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
a
str(a)
document()
load_all()
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = 2)
tableHTML(mtcars) %>%
add_css_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
headers = c(1, 4) )
load_all()
tableHTML(mtcars, second_header = list(c(3,4,5), c('col1', 'col2', 'col3'))) %>%
add_css_second_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
second_headers = 1)
load_all()
tableHTML(mtcars, second_header = list(c(3,4,5), c('col1', 'col2', 'col3'))) %>%
add_css_second_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
second_headers = 1)
load_all()
tableHTML(mtcars, second_header = list(c(3,4,5), c('col1', 'col2', 'col3'))) %>%
add_css_second_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
second_headers = 1)
tableHTML(mtcars, second_header = list(c(3,4,5), c('col1', 'col2', 'col3'))) %>%
add_css_second_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
second_headers = c(1,3))
tableHTML(mtcars, second_header = list(c(3,4,5), c('col1', 'col2', 'col3'))) %>%
add_css_second_header(css = list(c('background-color', 'border'), c('lightgray', '3px solid green')),
second_headers = c(1,2,3))
document()
load_all()
document()
load_all()
?add_css_second_header
odd <- function(vec) {
vec[vec %% 2 == 1]
}
even <- function(vec) {
vec[vec %% 2 == 1]
}
odd(1:10)
even(1:10)
odd <- function(vec) {
vec[vec %% 2 == 1]
}
even <- function(vec) {
vec[vec %% 2 == 0]
}
even
even(1:10)
load_all()
document()
?even
?odd
document()
?odd
document()
?odd
document()
?odd
?even
document()
?odd
?even
?odd_even
?even
